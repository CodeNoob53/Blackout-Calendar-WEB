# Оптимізація анімацій: Технічний посібник

Цей документ пояснює кроки, зроблені для усунення лагів при відкритті модальних вікон та бургер-меню, особливо при використанні ефекту скла (`backdrop-filter`).

## 1. Апаратне прискорення (GPU Acceleration)

**Проблема**: За замовчуванням браузер виконує анімації на CPU (центральному процесорі), що може призводити до затримок, якщо паралельно виконується JavaScript або складний рендеринг.

**Рішення**:
*   **`will-change: transform, opacity;`**: Підказує браузеру заздалегідь, які властивості зміняться. Це дозволяє браузеру винести елемент на окремий "шар" (layer) у графічній пам'яті.
*   **`transform: translate3d(0, 0, 0);`**: Примусово вмикає GPU-композитинг. Навіть якщо ми не використовуємо 3D, це "хак", який гарантує, що елемент обробляється відеокартою.

```css
.modal-content {
  will-change: transform, opacity;
  transform: translate3d(0, 0, 0);
}
```

## 2. Відключення дорогих фільтрів на нижніх шарах

**Проблема**: `backdrop-filter: blur()` — це одна з найдорожчих операцій для браузера. Коли ми анімуємо модальне вікно *поверх* іншого контенту, який також має блюр або складні градієнти, GPU змушений перераховувати ці пікселі 60 разів на секунду для всієї площі екрана.

**Рішення**:
Коли модальне вікно відкрите, ми додаємо клас до `body` і **вимикаємо** блюр/фільтри для всього, що знаходиться *під* ним. Оскільки ці елементи все одно перекриті модалкою або бекдропом, користувач не помітить різниці, але навантаження на відеокарту впаде майже до нуля.

```css
/* В modal.css або burger-menu.css */
body.modal-open .app-root {
  filter: none !important;
  backdrop-filter: none !important;
}
```

## 3. Ізоляція рендерингу (Layout Containment)

**Проблема**: Коли елемент рухається, браузер може вирішити перерахувати геометрію (layout) всієї сторінки, щоб переконатися, що нічого не зсунулося.

**Рішення**:
*   **`contain: content;`**: Каже браузеру, що вміст цього елемента ніяк не впливає на зовнішній контент і навпаки. Це обмежує область перерахунків тільки самим модальним вікном.

```css
.modal-content {
  contain: content;
}
```

## 4. Управління станом у React

Ми використовуємо `useEffect`, щоб динамічно керувати класами на рівні `body`, оскільки модалки рендериться через `Portal` поза основним деревом DOM.

```tsx
useEffect(() => {
  if (isOpen) {
    document.body.classList.add('modal-open');
  } else {
    document.body.classList.remove('modal-open');
  }
  // Cleanup-функція гарантує видалення класу при розмонтуванні компонента
  return () => document.body.classList.remove('modal-open');
}, [isOpen]);
```

---
**Порада на майбутнє**: Завжди намагайтеся не анімувати властивості, що впливають на Layout (`height`, `width`, `top`, `left`). Використовуйте тільки `transform` та `opacity` — вони найкраще оптимізовані в сучасних браузерах.

## 5. Оптимізація перемикання тем

**Проблема**: При зміні класу `light`/`dark` на кореневому елементі, сотні елементів одночасно починають анімувати зміну кольорів, фонів та тіней. Це створює величезне навантаження (Paint Storm), що призводить до лагів на мобільних пристроях.

**Рішення**:
1.  **Тимчасове вимкнення анімацій**: Під час зміни теми ми додаємо спеціальний клас `.no-transitions`, який миттєво вимикає всі `transition` для всіх елементів.
2.  **Швидка зміна фону**: Ми скорочуємо час анімації фону `body` (наприклад, з 0.5с до 0.3с), щоб перемикання відчувалося швидшим і менш енергозатратним.

```css
/* base.css */
.no-transitions * {
  transition: none !important;
}
```

```tsx
/* App.tsx */
const toggleTheme = () => {
  document.documentElement.classList.add('no-transitions');
  setTheme(prev => prev === 'light' ? 'dark' : 'light');
  
  setTimeout(() => {
    document.documentElement.classList.remove('no-transitions');
  }, 100);
};
```

